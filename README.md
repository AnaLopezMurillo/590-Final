# 590-Final

# Elixir Problem 
### To run: cd into 'Elixir' folder and run: ```elixir animal.exs```
Program should run automatically to simulate object oriented programming as specified. 

I've written Elixir code that simulates the OO pillars, similar to Java, but in a functional-based language. One of the main downsides to not having the same base functionality and class-based programming style as Java is the way that the 'Main' function and class have to be set up. Because there are no classes in Elixir, we have to work with inheriting from a module system instead of direct abstract classes. We can, however, map certain parts of the OO functionality in Elixir similarly to Java. Abstraction in this program is handled by defining the 'abstract' module Animal, which creates a template object for sub-classes. Inheritance is handed by defining the Animal.Dog and Animal.Cat modules, which implement the specific versions of the two Animal module functions. Encapsulation is handled by the specific attribute 'name' sent as a paramater to each Animal object. The animal actor mailbox also has a specific getter 'getName' functionality to expose the name attribute of the object. Polymorphism was difficult to implement without the same built-in functionality as in Java, and the closest I was able to get it was by extending classes using a superclass Animal, and extending Dog and Cat modules by using Animal.Dog, Animal.Cat submodules. Overriding methods is therefore present in these two modules, since the Dog and Cat submodules have different functionality for the 'speak' function as their superclass Animal, but it is still a crude implementation of polymorphism as close to the Java functionality as possible.

# Go Problem
### To run: cd into 'Go' folder and run ```go run problem.go```

Program will print out a subsequence of numbers of the form 1^2, 2^2...30^2. 

(1): Because this program runs using buffered channels, there is no chance for deadlock. This is because the processes to add ints to the buffered channel are initialized and add odd/even integers sequentially on a process from 0-1500 milliseconds. Since the channels are buffered to have a maximum of 5 numbers, the consumer channel will wait until the next number is received before sending it to the final filter function. This ensures that numbers are consumed by the cons1 and cons2 functions sequentially in the order that they were pushed to the buffered channel. If a number is attempted to be pushed to inCh, but the channel is full, the program will just block push because of the buffered channel properties. This ensures no deadlock and that every number is processed.

(2): This is a little trickier in Elixir but handeable by setting different consumers to receive single channels from producers. For example, you could have producer A send to consumer A in the integer generation process itself, and finally set finalFilter to receive from both consumers A and B. This is also achievable by using other Elixir behaviors like GenServer, which are meant to exactly handle these situations. Users can define a starting producer module, consumer module, and link them, which will handle behavior as specified in the Go program.  